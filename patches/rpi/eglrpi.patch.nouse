diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index a04b9c6..96d6a0c 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -214,6 +214,9 @@ bool CEGLNativeTypeRaspberryPI::GetNativeResolution(RESOLUTION_INFO *res) const
 
     if ((tv_state.state & ( VC_HDMI_HDMI | VC_HDMI_DVI )) != 0) // hdtv
     {
+      uint32_t disp_x, disp_y;
+      m_DllBcmHost->graphics_get_display_size(0, &disp_x, &disp_y);
+
       res->iScreen      = 0;
       res->bFullScreen  = true;
       res->iWidth       = tv_state.display.hdmi.width;
@@ -221,7 +224,7 @@ bool CEGLNativeTypeRaspberryPI::GetNativeResolution(RESOLUTION_INFO *res) const
       res->iScreenWidth = tv_state.display.hdmi.width;
       res->iScreenHeight= tv_state.display.hdmi.height;
       res->dwFlags      = MAKEFLAGS(tv_state.display.hdmi.group, tv_state.display.hdmi.mode, tv_state.display.hdmi.scan_mode);
-      res->fPixelRatio  = get_display_aspect_ratio((HDMI_ASPECT_T)tv_state.display.hdmi.display_options.aspect) / ((float)res->iScreenWidth / (float)res->iScreenHeight);
+      res->fPixelRatio  = get_display_aspect_ratio((HDMI_ASPECT_T)tv_state.display.hdmi.display_options.aspect) / ((float)disp_x / disp_y); // / ((float)res->iScreenWidth / (float)res->iScreenHeight);
       // Also add 3D flags
       if (tv_state.display.hdmi.format_3d == HDMI_3D_FORMAT_SBS_HALF)
       {
@@ -489,10 +492,12 @@ static void SetResolutionString(RESOLUTION_INFO &res)
   res.iWidth = gui_width;
   res.iHeight = gui_height;
 
-  res.strMode = StringUtils::Format("%dx%d (%dx%d) @ %.2f%s%s%s - Full Screen", res.iScreenWidth, res.iScreenHeight, res.iWidth, res.iHeight, res.fRefreshRate,
-    res.dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "",
-    res.dwFlags & D3DPRESENTFLAG_MODE3DTB   ? " 3DTB" : "",
-    res.dwFlags & D3DPRESENTFLAG_MODE3DSBS  ? " 3DSBS" : "");
+  res.strMode = StringUtils::Format("%4sx%4s (%4sx%4s) @ %.2f%s - Full Screen (%.3f) %s%s", StringUtils::Format("%d", res.iScreenWidth).c_str(),
+    StringUtils::Format("%d", res.iScreenHeight).c_str(), StringUtils::Format("%d", res.iWidth).c_str(),
+    StringUtils::Format("%d", res.iHeight).c_str(), res.fRefreshRate,
+    res.dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : " ", res.fPixelRatio,
+    res.dwFlags & D3DPRESENTFLAG_MODE3DTB   ? "3DTB" : "",
+    res.dwFlags & D3DPRESENTFLAG_MODE3DSBS  ? "3DSBS" : "");
 }
 #endif
 
@@ -599,6 +604,9 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
         group, num_modes, prefer_group, prefer_mode);
   }
 
+  uint32_t disp_x, disp_y;
+  m_DllBcmHost->graphics_get_display_size(0, &disp_x, &disp_y);
+
   if (num_modes > 0 && prefer_group != HDMI_RES_GROUP_INVALID)
   {
     TV_SUPPORTED_MODE_NEW_T *tv = supported_modes;
@@ -614,11 +622,11 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
       res.iHeight       = tv->height;
       res.iScreenWidth  = tv->width;
       res.iScreenHeight = tv->height;
-      res.fPixelRatio   = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res.iScreenWidth / (float)res.iScreenHeight);
+      res.fPixelRatio   = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)disp_x / disp_y);// / ((float)res.iScreenWidth / (float)res.iScreenHeight);
       res.iSubtitles    = (int)(0.965 * res.iHeight);
 
       AddUniqueResolution(res, resolutions);
-      CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f) %s%s:%x\n", i, res.strMode.c_str(), res.fPixelRatio,
+      CLog::Log(LOGDEBUG, "EGL mode %d: %s %s%s:%x\n", i, res.strMode.c_str(),
           tv->native ? "N" : "", tv->scan_mode ? "I" : "", tv->code);
 
       if (tv->frame_rate == 24 || tv->frame_rate == 30 || tv->frame_rate == 60)
@@ -633,12 +641,12 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
       {
         RESOLUTION_INFO res2 = res;
         res2.dwFlags |= D3DPRESENTFLAG_MODE3DSBS;
-        res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
+        res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)disp_x / disp_y);// / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
         res2.fPixelRatio   *= 2.0f;
         res2.iSubtitles    = (int)(0.965 * res2.iHeight);
 
         AddUniqueResolution(res2, resolutions);
-        CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f)\n", i, res2.strMode.c_str(), res2.fPixelRatio);
+        CLog::Log(LOGDEBUG, "EGL mode %d: %s\n", i, res2.strMode.c_str());
         if (tv->frame_rate == 24 || tv->frame_rate == 30 || tv->frame_rate == 60)
         {
           res2.fRefreshRate  = (float)tv->frame_rate * (1000.0f/1001.0f);
@@ -649,12 +657,12 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
       {
         RESOLUTION_INFO res2 = res;
         res2.dwFlags |= D3DPRESENTFLAG_MODE3DTB;
-        res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
+        res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)disp_x / disp_y);// / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
         res2.fPixelRatio   *= 0.5f;
         res2.iSubtitles    = (int)(0.965 * res2.iHeight);
 
         AddUniqueResolution(res2, resolutions);
-        CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f)\n", i, res2.strMode.c_str(), res2.fPixelRatio);
+        CLog::Log(LOGDEBUG, "EGL mode %d: %s\n", i, res2.strMode.c_str());
         if (tv->frame_rate == 24 || tv->frame_rate == 30 || tv->frame_rate == 60)
         {
           res2.fRefreshRate  = (float)tv->frame_rate * (1000.0f/1001.0f);
