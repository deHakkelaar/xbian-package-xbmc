commit ff50213c4b9e09de47fcbf3448d6c373326781ff
Author: Matus Kral <matuskral@me.com>
Date:   Tue Jul 29 14:59:00 2014 +0200

    imx6 EGL re-patch

diff --git a/xbmc/windowing/egl/EGLNativeTypeIMX.cpp b/xbmc/windowing/egl/EGLNativeTypeIMX.cpp
index 3dc64a3..7ad21d3 100644
--- a/xbmc/windowing/egl/EGLNativeTypeIMX.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeIMX.cpp
@@ -18,6 +18,8 @@
  *
  */
 
+#include "Application.h"
+
 #include <linux/mxcfb.h>
 #include "system.h"
 #include <EGL/egl.h>
@@ -34,10 +36,15 @@
 #include "windowing/WindowingFactory.h"
 #include "cores/AudioEngine/AEFactory.h"
 #include <fstream>
+#include "settings/Settings.h"
+
+#include "stdlib.h"
 
 CEGLNativeTypeIMX::CEGLNativeTypeIMX()
   : m_display(NULL)
   , m_window(NULL)
+  , m_aResume(false)
+  , m_show(true)
 {
 }
 
@@ -55,40 +62,26 @@ void CEGLNativeTypeIMX::Initialize()
 {
   int fd;
 
-  fd = open("/dev/fb0",O_RDWR);
-  if (fd < 0)
-  {
-    CLog::Log(LOGERROR, "%s - Error while opening /dev/fb0.\n", __FUNCTION__);
-    return;
-  }
-
-  // Unblank the fb
-  if (ioctl(fd, FBIOBLANK, 0) < 0)
-  {
-    CLog::Log(LOGERROR, "%s - Error while unblanking fb0.\n", __FUNCTION__);
-  }
-
-  close(fd);
+  system("/usr/bin/splash --force -b");
+  CLog::Log(LOGDEBUG, "%s\n", __FUNCTION__);
+  set_sysfs_str("/sys/class/graphics/fb0/blank", "0");
 
+  CSettings::Get().SetInt("audiooutput.streamsilence", -1);
+  CSettings::Get().SetInt("videoplayer.pauseafterrefreshchange", 0);
+  m_readOnly = true;
   // Check if we can change the framebuffer resolution
-  fd = open("/sys/class/graphics/fb0/mode", O_RDWR);
-  if (fd >= 0)
-  {
-    CLog::Log(LOGNOTICE, "%s - graphics sysfs is writable", __FUNCTION__);
-    m_readonly = false;
-  }
-  else
+  if ((fd = open("/sys/class/graphics/fb0/mode", O_RDWR)) >= 0)
   {
-    CLog::Log(LOGNOTICE, "%s - graphics sysfs is read-only", __FUNCTION__);
-    m_readonly = true;
+    m_readOnly = false;
+    close(fd);
   }
-  close(fd);
 
   return;
 }
 
 void CEGLNativeTypeIMX::Destroy()
 {
+  CLog::Log(LOGDEBUG, "%s\n", __FUNCTION__);
   struct fb_fix_screeninfo fixed_info;
   void *fb_buffer;
   int fd;
@@ -114,44 +107,52 @@ void CEGLNativeTypeIMX::Destroy()
   }
 
   close(fd);
-
   return;
 }
 
 bool CEGLNativeTypeIMX::CreateNativeDisplay()
 {
+  if (m_display)
+    return true;
+
+  CLog::Log(LOGDEBUG,": %s", __FUNCTION__);
+
   // Force double-buffering
   CEnvironment::setenv("FB_MULTI_BUFFER", "2", 0);
-
   // EGL will be rendered on fb0
-  m_display = fbGetDisplayByIndex(0);
-  m_nativeDisplay = &m_display;
+  if (!(m_display = fbGetDisplayByIndex(0)))
+    return false;
+  m_nativeDisplay = &m_display;
   return true;
 }
 
 bool CEGLNativeTypeIMX::CreateNativeWindow()
 {
-  m_window = fbCreateWindow(m_display, 0, 0, 0, 0);
-  m_nativeWindow = &m_window;
+  if (m_window)
+    return true;
+
+  CLog::Log(LOGDEBUG,": %s", __FUNCTION__);
+
+  if (!(m_window = fbCreateWindow(m_display, 0, 0, 0, 0)))
+    return false;
+  m_nativeWindow = &m_window;
   return true;
 }
 
 bool CEGLNativeTypeIMX::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
 {
-  if (!nativeDisplay)
-    return false;
   if (!m_nativeDisplay)
     return false;
+
   *nativeDisplay = (XBNativeDisplayType*)m_nativeDisplay;
   return true;
 }
 
 bool CEGLNativeTypeIMX::GetNativeWindow(XBNativeWindowType **nativeWindow) const
 {
-  if (!nativeWindow)
-    return false;
-  if (!m_nativeWindow || !m_window)
+  if (!m_nativeWindow)
     return false;
+
   *nativeWindow = (XBNativeWindowType*)m_nativeWindow;
   return true;
 }
@@ -160,7 +161,11 @@ bool CEGLNativeTypeIMX::DestroyNativeDisplay()
 {
   if (m_display)
     fbDestroyDisplay(m_display);
-  m_display =  NULL;
+
+  CLog::Log(LOGDEBUG,": %s", __FUNCTION__);
+
+  m_display = NULL;
+  m_nativeDisplay = NULL;
   return true;
 }
 
@@ -168,7 +173,19 @@ bool CEGLNativeTypeIMX::DestroyNativeWindow()
 {
   if (m_window)
     fbDestroyWindow(m_window);
-  m_window =  NULL;
+
+  CLog::Log(LOGDEBUG,": %s", __FUNCTION__);
+
+  if (!CAEFactory::IsSuspended() && !m_aResume)
+  {
+    m_aResume = true;
+    CAEFactory::Suspend();
+    while (!CAEFactory::IsSuspended())
+      Sleep(10);
+  }
+
+  m_window = NULL;
+  m_nativeWindow = NULL;
   return true;
 }
 
@@ -181,47 +198,64 @@ bool CEGLNativeTypeIMX::GetNativeResolution(RESOLUTION_INFO *res) const
 
 bool CEGLNativeTypeIMX::SetNativeResolution(const RESOLUTION_INFO &res)
 {
-  if (m_readonly)
+  if (m_readOnly)
     return false;
 
-  std::string mode;
-  get_sysfs_str("/sys/class/graphics/fb0/mode", mode);
-  if (res.strId == mode)
-    return false;
+  RESOLUTION_INFO c;
+  GetNativeResolution(&c);
+  if (res.strMode == c.strMode)
+    return true;
 
-  DestroyNativeWindow();
+  ShowWindow(false);
+  g_Windowing.DestroyWindow();
   DestroyNativeDisplay();
 
-  set_sysfs_str("/sys/class/graphics/fb0/mode", res.strId);
+  CLog::Log(LOGDEBUG,": %s - changing resolution to %s", __FUNCTION__, res.strId.c_str());
+  set_sysfs_str("/sys/class/graphics/fb0/mode", res.strId.c_str());
 
   CreateNativeDisplay();
-
-  CLog::Log(LOGDEBUG, "%s: %s",__FUNCTION__, res.strId.c_str());
-
-  // Reset AE
-  CAEFactory::DeviceChange();
-
   return true;
 }
 
+bool CEGLNativeTypeIMX::FindMatchingResolution(const RESOLUTION_INFO &act, const RESOLUTION_INFO &res, const std::vector<RESOLUTION_INFO> &resolutions)
+{
+  for (int i = 0; i < (int)resolutions.size(); i++)
+  {
+    if(resolutions[i].iScreenWidth == res.iScreenWidth &&
+       resolutions[i].iScreenHeight == res.iScreenHeight &&
+       resolutions[i].fRefreshRate == res.fRefreshRate)
+    {
+       return true;
+    }
+  }
+  return false;
+}
+
 bool CEGLNativeTypeIMX::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
 {
-  if (m_readonly)
+  if (m_readOnly)
     return false;
 
+  RESOLUTION_INFO act;
+  GetNativeResolution(&act);
+
   std::string valstr;
   get_sysfs_str("/sys/class/graphics/fb0/modes", valstr);
+
   std::vector<CStdString> probe_str;
   StringUtils::SplitString(valstr, "\n", probe_str);
+  std::sort(probe_str.begin(), probe_str.end());
 
   resolutions.clear();
   RESOLUTION_INFO res;
   for (size_t i = 0; i < probe_str.size(); i++)
   {
-    if(!StringUtils::StartsWith(probe_str[i], "S:"))
+    if(!StringUtils::StartsWith(probe_str[i], "S:") && !StringUtils::StartsWith(probe_str[i], "U:"))
       continue;
+
     if(ModeToResolution(probe_str[i], &res))
-      resolutions.push_back(res);
+      if(!FindMatchingResolution(act, res, resolutions))
+         resolutions.push_back(res);
   }
   return resolutions.size() > 0;
 }
@@ -233,48 +267,58 @@ bool CEGLNativeTypeIMX::GetPreferredResolution(RESOLUTION_INFO *res) const
 
 bool CEGLNativeTypeIMX::ShowWindow(bool show)
 {
-  // Force vsync by default
-  eglSwapInterval(g_Windowing.GetEGLDisplay(), 1);
-  EGLint result = eglGetError();
-  if(result != EGL_SUCCESS)
-    CLog::Log(LOGERROR, "EGL error in %s: %x",__FUNCTION__, result);
+  if (m_show == show)
+    return true;
 
-  return false;
+  CLog::Log(LOGDEBUG, ": %s %s", __FUNCTION__, show?"show":"hide");
+
+  set_sysfs_str("/sys/class/graphics/fb0/blank", show?"0":"1");
+  m_show = show;
+
+  if (show && m_aResume && CAEFactory::IsSuspended())
+  {
+    CAEFactory::Resume();
+    while (CAEFactory::IsSuspended())
+      Sleep(10);
+    m_aResume = false;
+  }
+  return true;
 }
 
-int CEGLNativeTypeIMX::get_sysfs_str(std::string path, std::string& valstr) const
+bool CEGLNativeTypeIMX::get_sysfs_str(std::string path, std::string& valstr) const
 {
   int len;
   char buf[256] = {0};
 
   int fd = open(path.c_str(), O_RDONLY);
-  if (fd >= 0)
-  {
-    while ((len = read(fd, buf, 255)) > 0)
-      valstr.append(buf, len);
-    close(fd);
-  }
-  else
+  if (fd < 0)
   {
     CLog::Log(LOGERROR, "%s: error reading %s",__FUNCTION__, path.c_str());
     valstr = "fail";
-    return -1;
+    return false;
   }
-  return 0;
+
+  while ((len = read(fd, buf, 255)) > 0)
+    valstr.append(buf, len);
+  close(fd);
+
+  return true;
 }
 
-int CEGLNativeTypeIMX::set_sysfs_str(std::string path, std::string val) const
+bool CEGLNativeTypeIMX::set_sysfs_str(std::string path, std::string val) const
 {
   int fd = open(path.c_str(), O_WRONLY);
-  if (fd >= 0)
+  if (fd < 0)
   {
-    val += '\n';
-    write(fd, val.c_str(), val.size());
-    close(fd);
-    return 0;
+    CLog::Log(LOGERROR, "%s: error writing %s",__FUNCTION__, path.c_str());
+    return false;
   }
-  CLog::Log(LOGERROR, "%s: error writing %s",__FUNCTION__, path.c_str());
-  return -1;
+
+  val += '\n';
+  write(fd, val.c_str(), val.size());
+  close(fd);
+
+  return true;
 }
 
 bool CEGLNativeTypeIMX::ModeToResolution(std::string mode, RESOLUTION_INFO *res) const
diff --git a/xbmc/windowing/egl/EGLNativeTypeIMX.h b/xbmc/windowing/egl/EGLNativeTypeIMX.h
index df7b3b7..a348c6f 100644
--- a/xbmc/windowing/egl/EGLNativeTypeIMX.h
+++ b/xbmc/windowing/egl/EGLNativeTypeIMX.h
@@ -32,7 +32,7 @@ public:
   virtual bool  CheckCompatibility();
   virtual void  Initialize();
   virtual void  Destroy();
-  virtual int   GetQuirks() { return EGL_QUIRK_NONE; }
+  virtual int   GetQuirks() { return EGL_QUIRK_DESTROY_NATIVE_WINDOW_WITH_SURFACE | EGL_QUIRK_KEEP_CONTEXT; }
 
   virtual bool  CreateNativeDisplay();
   virtual bool  CreateNativeWindow();
@@ -47,14 +47,17 @@ public:
   virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
   virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
 
-  virtual bool  ShowWindow(bool show);
+  virtual bool  ShowWindow(bool show = true);
 
 protected:
-  bool m_readonly;
-  int get_sysfs_str(std::string path, std::string& valstr) const;
-  int set_sysfs_str(std::string path, std::string val) const;
+  bool m_aResume;
+  bool m_readOnly;
+  bool m_show;
+  bool get_sysfs_str(std::string path, std::string& valstr) const;
+  bool set_sysfs_str(std::string path, std::string val) const;
   bool ModeToResolution(std::string mode, RESOLUTION_INFO *res) const;
+  bool FindMatchingResolution(const RESOLUTION_INFO &act, const RESOLUTION_INFO &res, const std::vector<RESOLUTION_INFO> &resolutions);
 
-  EGLNativeDisplayType m_display;
-  EGLNativeWindowType  m_window;
+  EGLNativeDisplayType  m_display;
+  EGLNativeWindowType   m_window;
 };
diff --git a/xbmc/windowing/egl/EGLQuirks.h b/xbmc/windowing/egl/EGLQuirks.h
index 4778f97..e0c0c10 100644
--- a/xbmc/windowing/egl/EGLQuirks.h
+++ b/xbmc/windowing/egl/EGLQuirks.h
@@ -39,3 +39,8 @@
            size of -1, -1. Work around it for now
 */
 #define EGL_QUIRK_DONT_TRUST_SURFACE_SIZE (1 << 2)
+
+/*! \brief Enable this to avoid releasing the EGL context
+           This avoids a problem with texture creation failing when using "virtual suspend"
+*/
+#define EGL_QUIRK_KEEP_CONTEXT (1 << 3)
diff --git a/xbmc/windowing/egl/WinSystemEGL.cpp b/xbmc/windowing/egl/WinSystemEGL.cpp
index dfc4672..abcc628 100644
--- a/xbmc/windowing/egl/WinSystemEGL.cpp
+++ b/xbmc/windowing/egl/WinSystemEGL.cpp
@@ -289,17 +289,24 @@ bool CWinSystemEGL::DestroyWindow()
   if (!m_egl)
     return false;
 
-  m_egl->ReleaseContext(m_display);
+  int quirks;
+  m_egl->GetQuirks(&quirks);
+
+  if (!(quirks & EGL_QUIRK_KEEP_CONTEXT))
+    m_egl->ReleaseContext(m_display);
+
   if (m_surface != EGL_NO_SURFACE)
+  {
     m_egl->DestroySurface(m_surface, m_display);
+    m_surface = EGL_NO_SURFACE;
+  }
 
-  int quirks;
-  m_egl->GetQuirks(&quirks);
-  if (quirks & EGL_QUIRK_DESTROY_NATIVE_WINDOW_WITH_SURFACE)
+  if (m_surface == EGL_NO_SURFACE && (quirks & EGL_QUIRK_DESTROY_NATIVE_WINDOW_WITH_SURFACE))
+  {
     m_egl->DestroyNativeWindow();
+    m_bWindowCreated = false;
+  }
 
-  m_surface = EGL_NO_SURFACE;
-  m_bWindowCreated = false;
   return true;
 }
 
diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.cpp b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
index 970b822..5e16841 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
@@ -34,6 +34,7 @@
 #include "settings/AdvancedSettings.h"
 #include "cores/VideoRenderers/RenderFlags.h"
 
+#include "cores/AudioEngine/AEFactory.h"
 
 CBaseRenderer::CBaseRenderer()
 {
@@ -97,8 +98,11 @@ void CBaseRenderer::ChooseBestResolution(float fps)
   }
   else
 #endif
+  {
+    CAEFactory::DeviceChange();
     CLog::Log(LOGNOTICE, "Display resolution %s : %s (%d)",
         m_resolution == RES_DESKTOP ? "DESKTOP" : "USER", g_graphicsContext.GetResInfo(m_resolution).strMode.c_str(), m_resolution);
+  }
 }
 
 bool CBaseRenderer::FindResolutionFromOverride(float fps, float& weight, bool fallback)
